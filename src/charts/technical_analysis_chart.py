# === ÁâàÊú¨: Async Áï∞Ê≠•Ê•µÈÄüÁâà + ÈÄ±Á∑öÂàáÊèõ + ÊåâÈàï‰∫íÂãï ===

import os
import sys
import time
import asyncio
from dotenv import load_dotenv
load_dotenv()
import aiohttp
import pandas as pd
import numpy as np
import matplotlib
# Use Agg backend for non-GUI thread safety
matplotlib.use('Agg')
import matplotlib.pyplot as plt
import matplotlib.gridspec as gridspec
import matplotlib.ticker as mticker
import matplotlib.patches as patches
import mplfinance as mpf
import traceback
import platform
import glob
import json
from datetime import datetime, timedelta
from concurrent.futures import ThreadPoolExecutor

# ==========================================
#       ‚òÖ Ë®≠ÂÆöÂçÄ ‚òÖ
# ==========================================
FINMIND_TOKEN = os.getenv("FINMIND_TOKEN", "")
TELEGRAM_TOKEN = os.getenv("TELEGRAM_TOKEN", "")
TELEGRAM_CHAT_ID = os.getenv("TELEGRAM_CHAT_ID", "")
# Ë®≠ÂÆöË∑ØÂæë
BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
CACHE_FILE = os.path.join(BASE_DIR, "cache", "market_matrix.pkl")
DATA_FOLDER = os.path.join(BASE_DIR, "data_core", "history")
META_FOLDER = os.path.join(BASE_DIR, "data_core", "market_meta")

# ÂÖ®ÂüüËÆäÊï∏
DF_MANSFIELD_PR = None
DF_IBD_PR = None
STOCK_NAME_TO_ID = {} 
STOCK_ID_TO_NAME = {} 

# Â≠óÈ´îË®≠ÂÆö
system_name = platform.system()
if system_name == "Windows":
    plt.rcParams['font.sans-serif'] = ['Microsoft JhengHei']
elif system_name == "Darwin":
    plt.rcParams['font.sans-serif'] = ['Arial Unicode MS']
else:
    plt.rcParams['font.sans-serif'] = ['WenQuanYi Zen Hei']
plt.rcParams['axes.unicode_minus'] = False 

# ==========================================
#       ‚òÖ Ê†∏ÂøÉÂºïÊìé (CPU Bound) ‚òÖ
#       ‰∏ªË¶ÅÈÅãÁÆóÈÇèËºØ (‰øùÊåÅÂêåÊ≠•ÔºåÁî± Executor ÂëºÂè´)
# ==========================================

def build_stock_name_map():
    global STOCK_NAME_TO_ID
    print("üìñ Ê≠£Âú®Âª∫Á´ã‰∏≠ÊñáÁ¥¢Âºï...")
    
    # ÂÑ™ÂÖàÂòóË©¶Âæû CSV ËÆÄÂèñ (Generated by tools/generate_industry_map.py)
    map_file = os.path.join(META_FOLDER, "moneydj_industries_grouped.csv")
    if os.path.exists(map_file):
        try:
            # ÊîπÁî®ÊâãÂãïËÆÄÂèñ‰ª•ËôïÁêÜ Jagged Rows (Ê¨Ñ‰ΩçÊï∏‰∏çÂõ∫ÂÆö)
            with open(map_file, 'r', encoding='utf-8-sig') as f:
                lines = f.readlines()
                
            start_idx = 0
            if lines and "Code" in lines[0] and "Name" in lines[0]:
                start_idx = 1
                
            count = 0
            for line in lines[start_idx:]:
                parts = line.split(',')
                if len(parts) >= 2:
                    sid = parts[0].strip()
                    name = parts[1].strip()
                    if sid and name:
                        STOCK_NAME_TO_ID[name] = sid
                        STOCK_ID_TO_NAME[sid] = name
                        count += 1
                        
            print(f"‚úÖ ‰∏≠ÊñáÁ¥¢ÂºïÂª∫Á´ãÂÆåÊàê (‰æÜËá™ CSV, ÂÖ± {count} Ê™î)")
            return
        except Exception as e:
            print(f"‚ö†Ô∏è CSV ËÆÄÂèñÂ§±Êïó: {e}")

    # Fallback to API
    print("‚ö†Ô∏è Êâæ‰∏çÂà∞ CSV ÊàñËÆÄÂèñÂ§±ÊïóÔºåÂòóË©¶ API...")
    url = "https://api.finmindtrade.com/api/v4/data"
    parameter = {"dataset": "TaiwanStockInfo", "token": FINMIND_TOKEN}
    try:
        import requests
        resp = requests.get(url, params=parameter, timeout=10)
        data = resp.json()
        if "data" in data:
            for item in data["data"]:
                name = item.get("stock_name", "").strip()
                sid = item.get("stock_id", "").strip()
                if name and sid:
                    name = name.replace("ËÇ°‰ªΩÊúâÈôêÂÖ¨Âè∏", "").replace("ÂÖ¨Âè∏", "").replace("ÁßëÊäÄ", "Áßë").replace("ÈõªÂ≠ê", "Èõª")
                    STOCK_NAME_TO_ID[name] = sid
                    STOCK_ID_TO_NAME[sid] = name
            print(f"‚úÖ ‰∏≠ÊñáÁ¥¢ÂºïÂª∫Á´ãÂÆåÊàê (‰æÜËá™ API, ÂÖ± {len(STOCK_NAME_TO_ID)} Ê™î)")
    except Exception as e:
        print(f"‚ùå Âª∫Á´ãÁ¥¢ÂºïÂ§±Êïó: {e}")

def initialize_market_matrix():
    global DF_MANSFIELD_PR, DF_IBD_PR
    
    build_stock_name_map()
    
    # ËÆÄÂèñ Cache
    # ËÆÄÂèñ Cache
    # ÂòóË©¶ÂÖ©ÂÄã‰ΩçÁΩÆ: 1. Áï∂ÂâçÁõÆÈåÑ (src) 2. ‰∏ä‰∏ÄÂ±§ (ËàäÂÆπÈåØ)
    possible_paths = [
        os.path.join(BASE_DIR, "cache", "market_matrix.pkl"),
        os.path.join(BASE_DIR, "market_matrix.pkl"),
        os.path.join(BASE_DIR, "..", "market_matrix.pkl")
    ]
    
    cache_file = None
    for p in possible_paths:
        if os.path.exists(p):
            cache_file = p
            break
            
    if cache_file:
        try:
            import pickle
            with open(cache_file, 'rb') as f:
                data = pickle.load(f)
                DF_MANSFIELD_PR = data.get('mansfield_pr')
                DF_IBD_PR = data.get('ibd_pr')
            print("‚úÖ Âø´ÂèñËºâÂÖ•ÊàêÂäüÔºÅ")
            return
        except: pass
    
    print("‚ö†Ô∏è ÁÑ°Âø´ÂèñÊàñËºâÂÖ•Â§±ÊïóÔºåÁï•ÈÅéÂÖ®Â∏ÇÂ†¥ÊéíË°åÂàùÂßãÂåñ (ÂäüËÉΩÂ∞áÂèóÈôê)")

# --- Ë≥áÊñôËÆÄÂèñËàáË®àÁÆó ---

def fetch_local_data(data_id, time_frame='D'):
    """
    ÂæûÊú¨Âú∞ CSV ËÆÄÂèñË≥áÊñô
    time_frame: 'D' (Êó•Á∑ö) or 'W' (ÈÄ±Á∑ö)
    """

    local_path = os.path.join(DATA_FOLDER, f"{data_id}.csv")
    if not os.path.exists(local_path):
        # ÂòóË©¶Âæû Meta Ë≥áÊñôÂ§æÊâæ (‰æãÂ¶Ç TAIEX)
        local_path = os.path.join(META_FOLDER, f"{data_id}.csv")
        if not os.path.exists(local_path):
            return None

    try:
        df = pd.read_csv(local_path)
        df['Date'] = pd.to_datetime(df['Date'])
        # Á¢∫‰øùÊ†ºÂºè
        expected_cols = ['Date', 'Open', 'High', 'Low', 'Close', 'Volume']
        if not all(c in df.columns for c in expected_cols): return None
        
        df = df.set_index('Date').sort_index()
        df = df[~df.index.duplicated(keep='last')] # ÂéªÈáç

        # ‚òÖ ÈÄ±Á∑öËôïÁêÜ ‚òÖ
        if time_frame == 'W':
            # Resample to Weekly (Ending Friday)
            df_weekly = df.resample('W-FRI').agg({
                'Open': 'first',
                'High': 'max',
                'Low': 'min',
                'Close': 'last',
                'Volume': 'sum'
            })
            # ÁßªÈô§Áï∂ÈÄ±ÈÇÑÊ≤íÈñãÁõ§ÁöÑÁ©∫Ë≥áÊñô (Ëã•Êúâ)
            df_weekly = df_weekly.dropna()
            return df_weekly
        
        return df
    except:
        return None

def get_stock_name_sync(stock_id):
    return STOCK_ID_TO_NAME.get(stock_id, stock_id)

def calculate_indicators(stock_id, time_frame='D', days=1500):
    """ Ë®àÁÆóÊäÄË°ìÊåáÊ®ô (CPUÂØÜÈõÜ) """
    df_stock = fetch_local_data(stock_id, time_frame)
    if df_stock is None or df_stock.empty: return None
    
    # Êì∑ÂèñÊúÄËøë N Â§©/ÈÄ±
    # Ê≥®ÊÑè: ÈÄ±Á∑ö days=1500 ÊúÉÂ§™Â§öÔºåÂèØ‰ª•Èô§‰ª• 5
    limit = days if time_frame == 'D' else int(days/5)
    df_stock = df_stock.iloc[-limit:].copy()

    # 1. Mansfield / IBD (ÈÄ±Á∑öÊôÇÈÄô‰∫õÊåáÊ®ôÁöÑÊÑèÁæ©ÊúÉËÆäÔºåÈÄôÈÇäÁ∞°ÂåñÔºöÂ¶ÇÊûúÊ≤íË≥áÊñôÂ∞±Â°´ NaN)
    # Ëã•ÊòØÈÄ±Á∑öÔºåÊàëÂÄëÊö´ÊôÇ‰∏çÈáçÊñ∞Ë®àÁÆóÂÖ®Â∏ÇÂ†¥ÈÄ±Á∑ö Rank (Â§™ËÄóÊôÇ)ÔºåÁõ¥Êé•Áî®Êó•Á∑öÊúÄÊñ∞ÂÄºÊàñÂ°´Á©∫
    # ÈÄôË£°ÈÅ∏ÊìáÔºöËã•ÊòØÈÄ±Á∑öÔºåÈÄôÂÖ©ÂÄãÊåáÊ®ôÊö´ÊôÇÈ°ØÁ§∫ 50 (‰∏≠‰ΩçÊï∏) Êàñ NaN
    
    if time_frame == 'D':
        if DF_MANSFIELD_PR is not None and stock_id in DF_MANSFIELD_PR.columns:
            pr_series = DF_MANSFIELD_PR[stock_id].reindex(df_stock.index).ffill()
            df_stock['Mansfield_PR'] = pr_series
        else:
            df_stock['Mansfield_PR'] = np.nan

        if DF_IBD_PR is not None and stock_id in DF_IBD_PR.columns:
            pr_series = DF_IBD_PR[stock_id].reindex(df_stock.index).ffill()
            df_stock['IBD_PR'] = pr_series
        else:
             df_stock['IBD_PR'] = np.nan
    else:
        # ÈÄ±Á∑öÊ®°ÂºèÔºöÊö´‰∏çÊîØÊè¥ÂÖ®Â∏ÇÂ†¥ÊåáÊ®ô
        df_stock['Mansfield_PR'] = 50
        df_stock['IBD_PR'] = 50

    # 2. MAs
    for w in [5, 10, 20, 50]:
        df_stock[f'MA{w}'] = df_stock['Close'].rolling(w).mean()

    # 3. BB
    df_stock['BB_Up'] = df_stock['MA20'] + 2 * df_stock['Close'].rolling(20).std()
    df_stock['BB_Low'] = df_stock['MA20'] - 2 * df_stock['Close'].rolling(20).std()
    
    # 4. Vol MA
    df_stock['Vol_MA5'] = df_stock['Volume'].rolling(5).mean()
    df_stock['Vol_MA20'] = df_stock['Volume'].rolling(20).mean()
    
    # 5. RSI (Wilder's Smoothing)
    delta = df_stock['Close'].diff()
    gain = (delta.where(delta > 0, 0)).fillna(0)
    loss = (-delta.where(delta < 0, 0)).fillna(0)
    for p in [6, 12, 14]: # Add 14 just in case, keep 6/12 for legacy
        # Wilder's Smoothing: alpha = 1/n or com = n-1
        avg_gain = gain.ewm(com=p-1, adjust=False).mean()
        avg_loss = loss.ewm(com=p-1, adjust=False).mean()
        df_stock[f'RSI_{p}'] = 100 - (100 / (1 + avg_gain/avg_loss))

    # 6. Indicator MAs (Mansfield/IBD)
    df_stock['Man_MA20'] = df_stock['Mansfield_PR'].rolling(20).mean()
    df_stock['Man_MA50'] = df_stock['Mansfield_PR'].rolling(50).mean()
    df_stock['IBD_MA20'] = df_stock['IBD_PR'].rolling(20).mean()
    df_stock['IBD_MA50'] = df_stock['IBD_PR'].rolling(50).mean()
    
    return df_stock

def draw_chart(stock_id, stock_name, df_full, plot_count, time_frame='D'):
    """ Áπ™ÂúñÂºïÊìé (CPUÂØÜÈõÜ) """
    df = df_full.iloc[-plot_count:].copy()
    if df.empty: return None
    
    last = df.iloc[-1]
    prev = df.iloc[-2] if len(df) > 1 else last
    
    chg = last['Close'] - prev['Close']
    pct = chg / prev['Close'] * 100 if prev['Close'] != 0 else 0

    # ÈÖçËâ≤ (Á∂≠ÊåÅ User ÂñúÂ•Ω)
    main_color = '#333333' if abs(pct) < 0.1 else ('#D32F2F' if pct > 0 else '#0097A7') 
    
    C_MA5, C_MA10, C_MA20, C_MA50 = '#Fbc02d', '#0288D1', '#00008B', '#D50000'
    C_BB = '#455A64'
    C_RSI6, C_RSI12 = C_MA5, '#D81B60'
    C_MAN, C_IBD = 'black', 'black'
    C_RS_MA20, C_RS_MA50 = C_MA5, C_MA10
    C_UP, C_DN, C_NEUT = '#FF5252', '#00C853', '#424242'

    # ‚òÖ Volume Fix: Convert Shares to Lots (ÂºµÊï∏)
    # User requested: "Volume is Lots, not Shares". The data source is Shares.
    # Convert for display: /1000
    df['Volume'] = df['Volume'] / 1000
    df['Vol_MA5'] = df['Vol_MA5'] / 1000
    df['Vol_MA20'] = df['Vol_MA20'] / 1000
    
    # Re-extract last after modification
    last = df.iloc[-1]

    def get_color(val, ref):
        if val > ref: return C_UP
        elif val < ref: return C_DN
        else: return C_NEUT
        
    def fmt_val(val, fmt='{:.1f}'): return fmt.format(val) if not pd.isna(val) else '-'

    # MPF Setup
    mc = mpf.make_marketcolors(up=C_UP, down=C_DN, edge='i', wick='i', volume='in')
    s = mpf.make_mpf_style(marketcolors=mc, rc={'font.family': plt.rcParams['font.sans-serif'][0], 'font.size': 10, 'axes.grid': True, 'grid.color': '#F0F0F0'})
    vol_colors = [C_UP if c >= o else C_DN for c, o in zip(df['Close'], df['Open'])]

    # Volume Profile
    price_min, price_max = df['Low'].min(), df['High'].max()
    bins = 20
    price_range = np.linspace(price_min, price_max, bins)
    vol_profile = np.zeros(bins-1)
    bin_indices = np.digitize((df['High']+df['Low'])/2, price_range) - 1
    for i, v in zip(bin_indices, df['Volume']): 
        if 0<=i<len(vol_profile): vol_profile[i]+=v
    vp_colors = []
    if len(vol_profile) > 0:
        uv = sorted(list(set(vol_profile)), reverse=True)
        v1 = uv[0] if uv else 0
        v2 = uv[1] if len(uv)>1 else 0
        for v in vol_profile:
            if v==v1: vp_colors.append('#FF5252')
            elif v==v2: vp_colors.append('#FFA726')
            else: vp_colors.append('#00BFFF')

    # Data Arrays
    mansfield_vals = df['Mansfield_PR'].values
    fb_up = np.where(mansfield_vals >= 87, mansfield_vals, np.nan)
    
    # Extract Values for Info Panel
    vol_val = last['Volume']
    vol_ma5 = last['Vol_MA5']
    vol_ma20 = last['Vol_MA20']
    
    rsi6 = last['RSI_6']
    rsi12 = last['RSI_12']
    
    man_val = last['Mansfield_PR']
    man_ma20 = last['Man_MA20']
    man_ma50 = last['Man_MA50']
    
    ibd_val = last['IBD_PR']
    ibd_ma20 = last['IBD_MA20']
    ibd_ma50 = last['IBD_MA50']

    # Figure Layout (Merged RS Chart)
    fig = plt.figure(figsize=(13, 24), facecolor='white') # Reduced height further
    gs = gridspec.GridSpec(11, 1, height_ratios=[1.7, 5.5, 0.1, 0.7, 1.2, 0.1, 0.7, 1.2, 0.1, 0.7, 1.2])
    
    ax_header = fig.add_subplot(gs[0])
    ax_main = fig.add_subplot(gs[1])
    ax_vol_info = fig.add_subplot(gs[3])
    ax_vol = fig.add_subplot(gs[4], sharex=ax_main)
    ax_rsi_info = fig.add_subplot(gs[6])
    ax_rsi = fig.add_subplot(gs[7], sharex=ax_main)
    ax_rs_info = fig.add_subplot(gs[9])
    ax_rs = fig.add_subplot(gs[10], sharex=ax_main) # Merged RS Chart

    for ax in [ax_header, ax_vol_info, ax_rsi_info, ax_rs_info]:
        ax.set_axis_off()

    # Header Card (Lines 304-382 Remain same - Skip update if possible, but replace_file_content needs contiguous block)
    # To minimize lines replaced, I can try to start replacement closer to Info Text section?
    # But extraction was at line 284. And Info Text at 383.
    # The tool requires single contiguous block.
    # I will replace from Line 284 to 401. (Large block but safe).
    
    rect = patches.FancyBboxPatch((0.01, 0.04), 0.98, 0.92, boxstyle="round,pad=0.03,rounding_size=0.08", 
                                  linewidth=6, edgecolor='#333333', facecolor='#F8F8F8', transform=ax_header.transAxes, zorder=0)
    ax_header.add_patch(rect)

    # Updated Color Scheme
    C_MA5 = '#FFA500' 
    C_MA10 = '#1E90FF' 
    C_MA20 = '#0000CD' 
    C_MA50 = '#DC143C' 
    
    C_RSI6 = '#FFA500'
    C_RSI12 = '#9370DB'
    
    C_MAN = 'black'
    C_IBD = 'black'
    C_RS_MA20 = '#FFA500'
    C_RS_MA50 = '#1E90FF'

    # Info Text - Refined Layout
    tf_str = "ÈÄ±Á∑ö" if time_frame == 'W' else "Êó•Á∑ö"
    ax_header.text(0.02, 0.82, f"{stock_id} {stock_name}", fontsize=28, weight='bold', color='#212121', transform=ax_header.transAxes)
    
    price_sym = '‚ñ≤' if chg > 0 else ('‚ñº' if chg < 0 else '')
    ax_header.text(0.02, 0.60, f"{last['Close']} {price_sym} {abs(chg):.1f} ({pct:+.2f}%)", fontsize=24, weight='bold', color=main_color, transform=ax_header.transAxes)

    ma_y = 0.60
    ax_header.text(0.42, ma_y, f"MA5:{fmt_val(last['MA5'])}", fontsize=16, color=C_MA5, weight='bold', transform=ax_header.transAxes)
    ax_header.text(0.57, ma_y, f"MA10:{fmt_val(last['MA10'])}", fontsize=16, color=C_MA10, weight='bold', transform=ax_header.transAxes)
    ax_header.text(0.72, ma_y, f"MA20:{fmt_val(last['MA20'])}", fontsize=16, color=C_MA20, weight='bold', transform=ax_header.transAxes)
    ax_header.text(0.87, ma_y, f"MA50:{fmt_val(last['MA50'])}", fontsize=16, color=C_MA50, weight='bold', transform=ax_header.transAxes)

    ref_price = prev['Close']
    c_o = get_color(last['Open'], ref_price)
    c_h = get_color(last['High'], ref_price)
    c_l = get_color(last['Low'], ref_price)
    c_c = get_color(last['Close'], ref_price) 
    
    ax_header.text(0.02, 0.36, "Èñã:", fontsize=18, color='gray', transform=ax_header.transAxes)
    ax_header.text(0.06, 0.36, f"{last['Open']}", fontsize=18, weight='bold', color=c_o, transform=ax_header.transAxes)
    ax_header.text(0.20, 0.36, "È´ò:", fontsize=18, color='gray', transform=ax_header.transAxes)
    ax_header.text(0.24, 0.36, f"{last['High']}", fontsize=18, weight='bold', color=c_h, transform=ax_header.transAxes)

    ax_header.text(0.02, 0.12, "‰Ωé:", fontsize=18, color='gray', transform=ax_header.transAxes)
    ax_header.text(0.06, 0.12, f"{last['Low']}", fontsize=18, weight='bold', color=c_l, transform=ax_header.transAxes)
    ax_header.text(0.20, 0.12, "Êî∂:", fontsize=18, color='gray', transform=ax_header.transAxes)
    ax_header.text(0.24, 0.12, f"{last['Close']}", fontsize=18, weight='bold', color=c_c, transform=ax_header.transAxes)

    ax_header.text(0.42, 0.36, f"BB+: {fmt_val(last['BB_Up'])}", fontsize=16, color='#555555', transform=ax_header.transAxes)
    ax_header.text(0.42, 0.12, f"BB-: {fmt_val(last['BB_Low'])}", fontsize=16, color='#555555', transform=ax_header.transAxes)

    # Sub-Indicators Text (Centers vertically)
    # Volume
    ax_vol_info.text(0.01, 0.3, "Êàê‰∫§Èáè", fontsize=20, weight='bold', color='black', transform=ax_vol_info.transAxes)
    ax_vol_info.text(0.20, 0.3, f"Vol: {int(vol_val):,}", fontsize=16, color='#333333', transform=ax_vol_info.transAxes)
    ax_vol_info.text(0.45, 0.3, f"VMA5: {int(vol_ma5):,}", fontsize=16, color=C_MA5, transform=ax_vol_info.transAxes)
    ax_vol_info.text(0.70, 0.3, f"VMA20: {int(vol_ma20):,}", fontsize=16, color=C_MA10, transform=ax_vol_info.transAxes)
    
    # RSI
    ax_rsi_info.text(0.01, 0.3, "RSI", fontsize=20, weight='bold', color='black', transform=ax_rsi_info.transAxes)
    ax_rsi_info.text(0.20, 0.3, f"RSI(6): {rsi6:.1f}", fontsize=16, weight='bold', color=C_RSI6, transform=ax_rsi_info.transAxes)
    ax_rsi_info.text(0.45, 0.3, f"RSI(12): {rsi12:.1f}", fontsize=16, weight='bold', color=C_RSI12, transform=ax_rsi_info.transAxes)
    
    # Combined RS
    C_MAN_LINE = '#00897B'
    C_IBD_LINE = '#C2185B'
    
    ax_rs_info.text(0.01, 0.3, "RS Strength", fontsize=20, weight='bold', color='black', transform=ax_rs_info.transAxes)
    ax_rs_info.text(0.20, 0.3, f"Mansfield: {man_val:.1f}", fontsize=16, weight='bold', color=C_MAN_LINE, transform=ax_rs_info.transAxes)
    ax_rs_info.text(0.55, 0.3, f"IBD: {ibd_val:.1f}", fontsize=16, weight='bold', color=C_IBD_LINE, transform=ax_rs_info.transAxes)

    # Plots
    apds = [
        mpf.make_addplot(df['MA5'], ax=ax_main, color=C_MA5, width=2.0),
        mpf.make_addplot(df['MA10'], ax=ax_main, color=C_MA10, width=2.2),
        mpf.make_addplot(df['MA20'], ax=ax_main, color=C_MA20, width=2.5),
        mpf.make_addplot(df['MA50'], ax=ax_main, color=C_MA50, width=2.8),
        mpf.make_addplot(df['BB_Up'], ax=ax_main, color=C_BB, linestyle='--', width=1.5, alpha=0.5),
        mpf.make_addplot(df['BB_Low'], ax=ax_main, color=C_BB, linestyle='--', width=1.5, alpha=0.5),
        mpf.make_addplot(df['Volume'], type='bar', ax=ax_vol, color=vol_colors),
        mpf.make_addplot(df['Vol_MA5'], ax=ax_vol, color=C_MA5, width=2.0),
        mpf.make_addplot(df['Vol_MA20'], ax=ax_vol, color=C_MA10, width=2.2),
        mpf.make_addplot(df['RSI_6'], ax=ax_rsi, color=C_RSI6, width=2.2),
        mpf.make_addplot(df['RSI_12'], ax=ax_rsi, color=C_RSI12, width=2.2),
        mpf.make_addplot(np.full(len(df),80), ax=ax_rsi, color='gray', linestyle=':', width=1.0),
        mpf.make_addplot(np.full(len(df),20), ax=ax_rsi, color='gray', linestyle=':', width=1.0),
        # Duplicate line removed
        
        # Merged RS (Mansfield + IBD) - NO MA
        mpf.make_addplot(df['Mansfield_PR'], ax=ax_rs, color=C_MAN_LINE, width=2.5),
        mpf.make_addplot(df['IBD_PR'], ax=ax_rs, color=C_IBD_LINE, width=2.5),
        
        # Ref Lines (Unified to 85, Gray)
        mpf.make_addplot(np.full(len(df),85), ax=ax_rs, color='gray', linestyle='--', width=1.0, alpha=0.5), # Unified Ref
    ]

    mpf.plot(df, type='candle', ax=ax_main, addplot=apds, style=s, datetime_format='%Y-%m-%d')
    if len(vp_colors) > 0:
        ax_main.barh((price_range[:-1]+price_range[1:])/2, width=(vol_profile/vol_profile.max())*len(df)*0.98, height=(price_max-price_min)/bins*0.95, color=vp_colors, alpha=0.25, align='center', left=-5, zorder=0)

    # Axes Cleanup
    for ax in [ax_main, ax_vol, ax_rsi, ax_rs]:
        ax.yaxis.tick_right()
        ax.spines['top'].set_visible(False)
        ax.spines['left'].set_visible(False)
        if ax != ax_rs: plt.setp(ax.get_xticklabels(), visible=False)
        
    # Volume Axis Formatting (No scientific notation)
    ax_vol.yaxis.set_major_formatter(plt.FuncFormatter(lambda x, p: f'{int(x):,}'))

    plt.subplots_adjust(left=0.02, right=0.94, top=0.98, bottom=0.03, hspace=0.05)
    
    filename = f"{stock_id}_{time_frame}_{int(time.time())}.png"
    fig.savefig(filename)
    plt.close(fig)
    return filename

# ==========================================
#       ‚òÖ Async Bot (IO Bound) ‚òÖ
#       ËôïÁêÜ Telegram Ë´ãÊ±ÇËàáÈùûÂêåÊ≠•‰ªªÂãô
# ==========================================

async def send_photo_async(session, chat_id, file_path, caption="", buttons=None):
    """ ÁôºÈÄÅÂúñÁâá (Âê´ÊåâÈàï) """
    url = f"https://api.telegram.org/bot{TELEGRAM_TOKEN}/sendPhoto"
    data = aiohttp.FormData()
    data.add_field('chat_id', str(chat_id))
    data.add_field('caption', caption)
    
    if buttons:
        data.add_field('reply_markup', json.dumps(buttons))

    try:
        # ‰ΩøÁî® with open Á¢∫‰øùÊ™îÊ°àÊ≠£Á¢∫ÈóúÈñâ
        with open(file_path, 'rb') as f:
            data.add_field('photo', f, filename=os.path.basename(file_path))
            async with session.post(url, data=data) as resp:
                # print(f"Sent photo response: {resp.status}")
                pass
    except Exception as e:
        print(f"‚ùå Send Photo Error: {e}")
    finally:
        # Ê∏ÖÈô§Êö´Â≠òÊ™î (Ê≠§ÊôÇÊ™îÊ°àÊáâÂ∑≤ÈáãÊîæ)
        if os.path.exists(file_path): 
            try:
                os.remove(file_path)
            except Exception as e:
                print(f"‚ö†Ô∏è Delete Error: {e}")

async def send_message_async(session, chat_id, text):
    url = f"https://api.telegram.org/bot{TELEGRAM_TOKEN}/sendMessage"
    payload = {"chat_id": chat_id, "text": text}
    try:
        async with session.post(url, json=payload) as resp: 
            pass
    except: pass

async def process_stat_request(session, chat_id, stock_id, stock_name, time_frame='D'):
    """ 
    Â∑•‰ΩúÊµÅÁ®ãÔºö
    1. Âú® ThreadPool Ë®àÁÆóÊï∏Êìö (‰∏çÂç° EventLoop)
    2. Âú® ThreadPool Áï´Âúñ (‰∏çÂç° EventLoop)
    3. ÈÄèÈÅé aiohttp ÂõûÂÇ≥
    """
    loop = asyncio.get_running_loop()
    
    # Send "Processing" check
    # await send_message_async(session, chat_id, f"Running {stock_id} ({time_frame})...")

    try:
        # Step 1: Calc Indicators
        with ThreadPoolExecutor() as pool:
            df = await loop.run_in_executor(pool, calculate_indicators, stock_id, time_frame, 1000)
        
        if df is None:
            await send_message_async(session, chat_id, f"‚ùå {stock_id} ÁÑ°Ë≥áÊñô")
            return

        # Step 2: Draw Chart
        plot_count = 120 if time_frame=='D' else 60
        with ThreadPoolExecutor() as pool:
            img_path = await loop.run_in_executor(pool, draw_chart, stock_id, stock_name, df, plot_count, time_frame)

        # Step 3: Send
        if img_path:
            # Ê≠§ËôïÂÆöÁæ©ÂàáÊèõÊåâÈàï
            # Callback data format: "T:stock_id:D" or "T:stock_id:W"
            # T = Timeframe switch action
            opp_tf = 'W' if time_frame == 'D' else 'D'
            opp_text = "ÂàáÊèõÈÄ±Á∑ö" if time_frame == 'D' else "ÂàáÊèõÊó•Á∑ö"
            
            keyboard = {
                "inline_keyboard": [[
                    {"text": opp_text, "callback_data": f"T:{stock_id}:{opp_tf}"}
                ]]
            }
            
            
            # Debug: Add PID to caption to identify which instance replied
            my_pid = os.getpid()
            caption = f"üìä {stock_id} {stock_name} ({'Êó•Á∑ö' if time_frame=='D' else 'ÈÄ±Á∑ö'}) [PID:{my_pid}]"
            
            await send_photo_async(session, chat_id, img_path, caption, keyboard)
            print(f"‚úÖ {stock_id} ({time_frame}) Processed.")
        else:
            await send_message_async(session, chat_id, f"‚ùå {stock_id} Áπ™ÂúñÂ§±Êïó")

    except Exception as e:
        traceback.print_exc()
        await send_message_async(session, chat_id, f"‚ùå Error: {e}")

async def handle_updates(session, updates):
    for u in updates:
        # 1. ËôïÁêÜÊñ∞ÁöÑ Message
        if "message" in u:
            msg = u["message"]
            chat_id = msg.get("chat", {}).get("id")
            text = msg.get("text", "").strip().upper()
            
            if str(chat_id) != TELEGRAM_CHAT_ID: continue
            
            if text.startswith("K"):
                print(f"üì© CMD: {text}")
                # Parse
                raw = text[1:].strip() # "2330" or "Âè∞Á©çÈõª"
                target = raw.split('-')[0] # ÂøΩÁï• -200 ÂèÉÊï∏ (Âõ†ÁÇ∫ÊàëÂÄëÁèæÂú®ÊúâÊåâÈàï‰∫Ü)
                
                # Name Map
                sid = STOCK_NAME_TO_ID.get(target, target)
                
                if sid == "TAIEX" or (sid.isdigit() and len(sid)==4):
                    sname = get_stock_name_sync(sid) if sid!="TAIEX" else "Âä†Ê¨äÊåáÊï∏"
                    # Fire and forget task
                    asyncio.create_task(process_stat_request(session, chat_id, sid, sname, 'D'))
        
        # 2. ËôïÁêÜÊåâÈàï Callback
        if "callback_query" in u:
            cb = u["callback_query"]
            chat_id = cb["message"]["chat"]["id"]
            data = cb.get("data", "")
            # "T:2330:W"
            if data.startswith("T:"):
                parts = data.split(":")
                if len(parts) == 3:
                    sid = parts[1]
                    tf = parts[2]
                    sname = get_stock_name_sync(sid) if sid!="TAIEX" else "Âä†Ê¨äÊåáÊï∏"
                    print(f"üñ±Ô∏è Click: {sid} -> {tf}")
                    # Answer callback to stop loading animation
                    # (Simple GET to answerCallbackQuery)
                    try:
                        aid = cb["id"]
                        await session.get(f"https://api.telegram.org/bot{TELEGRAM_TOKEN}/answerCallbackQuery?callback_query_id={aid}")
                    except: pass
                    
                    asyncio.create_task(process_stat_request(session, chat_id, sid, sname, tf))

async def main():
    print("üöÄ Async Chart Bot Starting...")
    
    # Init Data
    initialize_market_matrix()
    
    offset = 0
    async with aiohttp.ClientSession() as session:
        print("‚úÖ Polling started. Waiting for commands (K2330)...")
        while True:
            try:
                url = f"https://api.telegram.org/bot{TELEGRAM_TOKEN}/getUpdates?timeout=10&offset={offset}"
                async with session.get(url) as resp:
                    if resp.status == 200:
                        data = await resp.json()
                        result = data.get("result", [])
                        if result:
                            offset = result[-1]["update_id"] + 1
                            await handle_updates(session, result)
            except Exception as e:
                print(f"Polling Error: {e}")
                await asyncio.sleep(5)
            
            # Tiny sleep to yield loop (aiohttp handles IO wait, but good practice)
            await asyncio.sleep(0.1)

if __name__ == "__main__":
    if sys.platform == 'win32':
        asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("üõë Bot Stopped.")